// Copyright 2022 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

//go:generate go-winres make --product-version=git-tag --file-version=git-tag

package main

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/atc0005/check-mail/internal/config"
	"github.com/atc0005/go-nagios"
	"github.com/rs/zerolog"
)

func main() {

	ctx := context.Background()

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	cfg, cfgErr := config.New(config.AppType{PluginIMAPMailboxOAuth2: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case errors.Is(cfgErr, config.ErrHelpRequested):
		fmt.Println(cfg.Help())

		return

	case cfgErr != nil:
		// We make some assumptions when setting up our logger as we do not
		// have a working configuration based on sysadmin-specified choices.
		consoleWriter := zerolog.ConsoleWriter{Out: os.Stderr, NoColor: true}
		logger := zerolog.New(consoleWriter).With().Timestamp().Caller().Logger()

		logger.Err(cfgErr).Msg("Error initializing application")

		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateUNKNOWNLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	// NOTE: This plugin is still intended for checking a single account, but
	// sufficient work is in place to allow bulk processing if there is
	// sufficient interest.
	for i, account := range cfg.Accounts {
		// Building with `go build -gcflags=all=-d=loopvar=2` identified this
		// loop as compiling differently with Go 1.22 (per-iteration) loop
		// semantics.
		//
		// As a workaround, we create a new variable for each iteration to
		// work around potential issues with Go versions prior to Go 1.22.
		account := account

		logger := cfg.Log.With().
			Str("client_id", account.OAuth2Settings.ClientID).
			Str("scopes", func() string {
				return strings.Join(account.OAuth2Settings.Scopes, ", ")
			}()).
			Str("shared_mailbox", account.OAuth2Settings.SharedMailbox).
			Str("server", account.Server).
			Int("port", account.Port).
			Str("folders_to_check", account.Folders.String()).
			Logger()

		// processAccount is responsible for setting the nagios.ExitState
		// values, logging errors, etc.
		results, err := processAccount(ctx, account, cfg, plugin, logger)
		if err != nil {
			return
		}

		// Evaluate whether anything was found and sound an alert if so
		if results.GotMail() {
			logger.Debug().Msgf("%d messages found: %s",
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			plugin.ServiceOutput = fmt.Sprintf(
				"%s: %s: %d messages found: %s",
				nagios.StateWARNINGLabel,
				account.Username,
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			plugin.ExitStatusCode = nagios.StateWARNINGExitCode

			return
		}

		if i+1 < len(cfg.Accounts) {
			// Delay processing the next account (unless we've processed them
			// all) in an attempt to prevent encountering the "User is
			// authenticated but not connected" error that is believed to
			// occur when remote connections limit is exceeded.
			time.Sleep(cfg.AccountProcessDelay())
		}

	}

	// Give the all clear: no mail was found
	cfg.Log.Debug().Msg("No messages found to report")

	// these values are known, consistent regardless of checking one or many
	// accounts
	plugin.ExitStatusCode = nagios.StateOKExitCode

	// customize ServiceOutput and LongServiceOutput based on number of
	// specified accounts
	setSummary(cfg.Accounts, plugin)

}
