// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

//go:generate go-winres make --product-version=git-tag --file-version=git-tag

package main

import (
	"errors"
	"fmt"

	zlog "github.com/rs/zerolog/log"

	"github.com/atc0005/check-mail/internal/config"
	"github.com/atc0005/check-mail/internal/mbxs"
	"github.com/atc0005/go-nagios"
)

func main() {

	// Start off assuming all is well, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	cfg, cfgErr := config.New(config.AppType{PluginIMAPMailboxBasicAuth: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.AddError(cfgErr)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	// loop over accounts
	for _, account := range cfg.Accounts {

		logger := cfg.Log.With().
			Str("username", account.Username).
			Str("server", account.Server).
			Int("port", account.Port).
			Str("folders_to_check", account.Folders.String()).
			Logger()

		c, connectErr := mbxs.Connect(account.Server, account.Port, cfg.NetworkType, cfg.MinTLSVersion(), logger)
		if connectErr != nil {
			logger.Error().Err(connectErr).Msg("error connecting to server")
			nagiosExitState.AddError(connectErr)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error connecting to %s",
				nagios.StateCRITICALLabel,
				account.Server,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

			return
		}

		if loginErr := mbxs.Login(c, account.Username, account.Password, logger); loginErr != nil {
			logger.Error().Err(loginErr).Msg("Login error occurred")
			nagiosExitState.AddError(loginErr)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Login error occurred",
				nagios.StateCRITICALLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			return
		}
		logger.Debug().Msg("Logged in")

		logger.Debug().Msg("Defer logout")
		// At this point in the code we are connected to the remote server and are
		// also logged in with a valid account. Calling os.Exit(X) at this point
		// will cause any deferred functions to be skipped, so we instead use
		// nagiosExitState.ReturnCheckResults() anywhere we would have called
		// os.Exit() with the intended status code. This allows us to safely defer
		// a Logout call here and have a reasonable expectation that it will both
		// run AND that we'll have an opportunity to report those logout issues as
		// this application exits.
		defer func(accountName string) {
			logger.Debug().Msgf("%s: Logging out", accountName)
			if err := c.Logout(); err != nil {
				logger.Error().Err(err).Msgf("%s: Failed to log out", accountName)
				nagiosExitState.AddError(err)
				nagiosExitState.ServiceOutput = fmt.Sprintf(
					"%s: Error logging out",
					nagios.StateWARNINGLabel,
				)
				nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
				return
			}
			logger.Debug().Msgf("%s: Logged out", accountName)
		}(account.Username)

		// Confirm that requested folders are present on server
		validatedMBXList, validateErr := mbxs.ValidateMailboxesList(
			c, account.Folders, logger)
		if validateErr != nil {
			nagiosExitState.AddError(validateErr)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: %s",
				nagios.StateCRITICALLabel,
				validateErr.Error(),
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

			return

		}

		results, chkMailErr := mbxs.CheckMail(c, account.Name, validatedMBXList, logger)
		if chkMailErr != nil {
			nagiosExitState.AddError(chkMailErr)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error occurred checking mail: %s",
				nagios.StateCRITICALLabel,
				chkMailErr.Error(),
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			return
		}

		// Evaluate whether anything was found and sound an alert if so
		if results.GotMail() {
			logger.Debug().Msgf("%d messages found: %s",
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: %s: %d messages found: %s",
				nagios.StateWARNINGLabel,
				account.Username,
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
			return
		}
	}

	// Give the all clear: no mail was found
	cfg.Log.Debug().Msg("No messages found to report")

	// these values are known, consistent regardless of checking one or many
	// accounts
	nagiosExitState.ExitStatusCode = nagios.StateOKExitCode

	// customize ServiceOutput and LongServiceOutput based on number of
	// specified accounts
	setSummary(cfg.Accounts, &nagiosExitState)

	// implied return here :)

}
