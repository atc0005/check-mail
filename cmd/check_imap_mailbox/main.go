// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/emersion/go-imap"
	"github.com/emersion/go-imap/client"
	"github.com/rs/zerolog"
	zlog "github.com/rs/zerolog/log"

	"github.com/atc0005/check-mail/internal/config"
	"github.com/atc0005/check-mail/internal/logging"
	"github.com/atc0005/check-mail/internal/mbxs"
	"github.com/atc0005/check-mail/internal/textutils"
	"github.com/atc0005/go-nagios"
)

// A baseline starting point for allocating slices to match "about" how many
// mailboxes will need to be checked on a remote mail server. This is defined
// here instead of hard-coding slice preallocation values.
const mailboxCountGuesstimate int = 30

func main() {

	// Start off assuming all is well, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags
	cfg := config.New()

	if err := cfg.Validate(); err != nil {
		// We're using the standalone Err function from rs/zerolog/log as we
		// have not yet created our own log value.
		zlog.Err(err).Msg("Error validating configuration")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error validating configuration",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.LastError = err
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	// Note: Nagios doesn't look at stderr, only stdout. We have to make sure
	// that only whatever output is meant for consumption is emitted to stdout
	// and whatever is meant for troubleshooting is sent to stderr. To help
	// keep these two goals separate (and because Nagios doesn't really do
	// anything special with JSON output from plugins), we use stdlib fmt
	// package output functions for Nagios via stdout and logging package for
	// troubleshooting via stderr.
	//
	// Also, set common fields here so that we don't have to repeat them
	// explicitly later. This will hopefully help to standardize the log
	// messages to make them easier to search through later when
	// troubleshooting.
	log := zerolog.New(os.Stderr).With().Caller().
		Str("version", config.Version()).
		Str("username", cfg.Username).
		Str("server", cfg.Server).
		Int("port", cfg.Port).
		Str("folders_to_check", cfg.Folders.String()).Logger()

	if err := logging.SetLoggingLevel(cfg.LoggingLevel); err != nil {
		log.Err(err).Msg("configuring logging level")
		nagiosExitState.LastError = err
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error configuring logging level",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		return
	}

	server := fmt.Sprintf("%s:%d", cfg.Server, cfg.Port)

	log.Debug().Msg("connecting to remote server")
	c, err := client.DialTLS(server, nil)
	if err != nil {
		log.Error().Err(err).Msgf("error connecting to server")
		nagiosExitState.LastError = err
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error connecting to %s",
			nagios.StateCRITICALLabel,
			server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		return
	}
	log.Debug().Msg("Connected")

	log.Debug().Msg("Logging in")
	if err := c.Login(cfg.Username, cfg.Password); err != nil {
		log.Error().Err(err).Msg("Login error occurred")
		nagiosExitState.LastError = err
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Login error occurred",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		return
	}
	log.Debug().Msg("Logged in")

	log.Debug().Msg("Defer logout")
	// At this point in the code we are connected to the remote server and are
	// also logged in with a valid account. Calling os.Exit(X) at this point
	// will cause any deferred functions to be skipped, so we instead use
	// nagiosExitState.ReturnCheckResults() anywhere we would have called
	// os.Exit() with the intended status code. This allows us to safely defer
	// a Logout call here and have a reasonable expectation that it will both
	// run AND that we'll have an opportunity to report those logout issues as
	// this application exits.
	defer func(accountName string) {
		log.Debug().Msg("Logging out")
		if err := c.Logout(); err != nil {
			log.Error().Err(err).Msg("")
			nagiosExitState.LastError = err
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error logging out",
				nagios.StateWARNINGLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
			return
		}
	}(cfg.Username)

	// Generate background job to list mailboxes, send down channel until done
	mailboxes := make(chan *imap.MailboxInfo, 10)
	done := make(chan error, 1)
	// NOTE: This goroutine shuts down once c.List() finishes its work
	go func() {
		log.Debug().Msg("Running c.List() to fetch a list of available mailboxes")
		done <- c.List("", "*", mailboxes)
	}()

	var mailboxesList = make([]string, 0, mailboxCountGuesstimate)
	for m := range mailboxes {
		log.Debug().Msg("collected mailbox from channel")
		mailboxesList = append(mailboxesList, m.Name)
	}

	if err := <-done; err != nil {
		log.Error().Err(err).Msg("Error occurred listing mailboxes")
		nagiosExitState.LastError = err
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error occurred listing mailboxes",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		return
	}

	log.Debug().Msg("no errors encountered listing mailboxes")

	// Prove that our slice is intact
	for _, m := range mailboxesList {
		log.Debug().Str("mailbox", m).Msg("")
	}

	// Confirm that requested folders are present on server
	var validatedMailboxesList = make([]string, 0, mailboxCountGuesstimate)
	for _, folder := range cfg.Folders {
		log.Debug().Str("mailbox", folder).Msg("Processing requested folder")

		// At this point we are looping over the requested folders, but
		// haven't yet confirmed that they exist as mailboxes on the remote
		// server.

		if strings.ToLower(folder) == "inbox" {

			// NOTE: The "inbox" mailbox/folder name is NOT case-sensitive,
			// but *all* others should be considered case-sensitive. We should
			// be able to safely skip validating "inbox" here since it is a
			// required mailbox/folder name, but all the same we will play it
			// safe and perform a case-insensitive check for a match.
			log.Debug().Str("mailbox", folder).Msg("Performing case-insensitive validation")
			if textutils.InList(folder, mailboxesList, true) {
				validatedMailboxesList = append(validatedMailboxesList, folder)
			}

			continue
		}

		log.Debug().Str("mailbox", folder).Msg("Performing case-sensitive validation")
		if textutils.InList(folder, mailboxesList, false) {

			// At this point we have confirmed that the requested folder to
			// monitor is in the list of folders found on the server
			log.Debug().Str("mailbox", folder).Bool("found", true).Msg("")
			validatedMailboxesList = append(validatedMailboxesList, folder)

		} else {

			log.Error().Str("mailbox", folder).Bool("found", false).Msg("")
			nagiosExitState.LastError = fmt.Errorf("mailbox not found: %q", folder)
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Mailbox not found",
				nagios.StateCRITICALLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			return
		}

	}

	// At this point we have created a list of validated mailboxes. Process
	// them to determine number of emails within each of them. Based on our
	// existing check and manual processing schedule, we normally see
	// somewhere between 1 and 5 mail items for normal accounts and under 30
	// for heavily spammed accounts. Preallocating the results slice with a
	// midrange starting value for now, but keeping the initial length at 0
	// to allow append() to work as expected.
	var results = make(mbxs.MailboxCheckResults, 0, 10)
	for _, folder := range validatedMailboxesList {

		log.Debug().Msg("Selecting mailbox")
		mailbox, err := c.Select(folder, false)
		if err != nil {
			log.Error().Err(err).Str("mailbox", folder).Msg("Error occurred selecting mailbox")
			nagiosExitState.LastError = err
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error occurred selecting mailbox %s",
				nagios.StateCRITICALLabel,
				folder,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			return
		}

		log.Debug().Str("mailbox", folder).Msgf("Mailbox flags: %v", mailbox.Flags)

		log.Debug().Msgf("%d mail items found in %s for %s",
			mailbox.Messages, folder, cfg.Username)

		results = append(results, mbxs.MailboxCheckResult{
			MailboxName: folder,
			ItemsFound:  int(mailbox.Messages),
		})
	}

	// Evaluate whether anything was found and sound an alert if so
	if results.GotMail() {
		log.Debug().Msgf("%d messages found: %s",
			results.TotalMessagesFound(),
			results.MessagesFoundSummary(),
		)
		nagiosExitState.LastError = nil
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: %s: %d messages found: %s",
			nagios.StateWARNINGLabel,
			cfg.Username,
			results.TotalMessagesFound(),
			results.MessagesFoundSummary(),
		)
		nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
		return
	}

	// Give the all clear: no mail was found
	log.Debug().Msg("No messages found to report")
	nagiosExitState.LastError = nil
	nagiosExitState.ServiceOutput = fmt.Sprintf(
		"%s: %s: No messages found in folders: %s",
		nagios.StateOKLabel,
		cfg.Username,
		cfg.Folders.String(),
	)
	nagiosExitState.ExitStatusCode = nagios.StateOKExitCode
	// implied return here :)

}
