// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"errors"
	"fmt"
	"strings"

	"github.com/emersion/go-imap"

	zlog "github.com/rs/zerolog/log"

	"github.com/atc0005/check-mail/internal/config"
	"github.com/atc0005/check-mail/internal/mbxs"
	"github.com/atc0005/check-mail/internal/textutils"
	"github.com/atc0005/go-nagios"
)

// A baseline starting point for allocating slices to match "about" how many
// mailboxes will need to be checked on a remote mail server. This is defined
// here instead of hard-coding slice preallocation values.
const mailboxCountGuesstimate int = 30

func main() {

	// Start off assuming all is well, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags. This plugin does
	// not currently support retrieving settings from a user-provided config
	// file. Because this may change in the near future, we are structuring
	// this plugin in a way to support that direction.
	useConfigFile := false
	cfg, cfgErr := config.New(useConfigFile)
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.LastError = cfgErr
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	// loop over accounts
	for _, account := range cfg.Accounts {

		logger := cfg.Log.With().
			Str("username", account.Username).
			Str("server", account.Server).
			Int("port", account.Port).
			Str("folders_to_check", account.Folders.String()).
			Logger()

		c, connectErr := mbxs.Connect(account.Server, account.Port, logger)
		if connectErr != nil {
			logger.Error().Err(connectErr).Msgf("error connecting to server")
			nagiosExitState.LastError = connectErr
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error connecting to %s",
				nagios.StateCRITICALLabel,
				account.Server,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

			return
		}

		if loginErr := mbxs.Login(c, account.Username, account.Password, logger); loginErr != nil {
			logger.Error().Err(loginErr).Msg("Login error occurred")
			nagiosExitState.LastError = loginErr
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Login error occurred",
				nagios.StateCRITICALLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

			return
		}

		logger.Debug().Msg("Defer logout")
		// At this point in the code we are connected to the remote server and are
		// also logged in with a valid account. Calling os.Exit(X) at this point
		// will cause any deferred functions to be skipped, so we instead use
		// nagiosExitState.ReturnCheckResults() anywhere we would have called
		// os.Exit() with the intended status code. This allows us to safely defer
		// a Logout call here and have a reasonable expectation that it will both
		// run AND that we'll have an opportunity to report those logout issues as
		// this application exits.
		defer func(accountName string) {
			logger.Debug().Msgf("%s: Logging out", accountName)
			if err := c.Logout(); err != nil {
				logger.Error().Err(err).Msgf("%s: Failed to log out", accountName)
				nagiosExitState.LastError = err
				nagiosExitState.ServiceOutput = fmt.Sprintf(
					"%s: Error logging out",
					nagios.StateWARNINGLabel,
				)
				nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
				return
			}
			logger.Debug().Msgf("%s: Logged out", accountName)
		}(account.Username)

		// Generate background job to list mailboxes, send down channel until done
		mailboxes := make(chan *imap.MailboxInfo, 10)
		done := make(chan error, 1)
		// NOTE: This goroutine shuts down once c.List() finishes its work
		go func() {
			logger.Debug().Msg("Running c.List() to fetch a list of available mailboxes")
			done <- c.List("", "*", mailboxes)
		}()

		var mailboxesList = make([]string, 0, mailboxCountGuesstimate)
		for m := range mailboxes {
			logger.Debug().Msg("collected mailbox from channel")
			mailboxesList = append(mailboxesList, m.Name)
		}

		if err := <-done; err != nil {
			logger.Error().Err(err).Msg("Error occurred listing mailboxes")
			nagiosExitState.LastError = err
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: Error occurred listing mailboxes",
				nagios.StateCRITICALLabel,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			return
		}

		logger.Debug().Msg("no errors encountered listing mailboxes")

		// Prove that our slice is intact
		for _, m := range mailboxesList {
			logger.Debug().Str("mailbox", m).Msg("")
		}

		// Confirm that requested folders are present on server
		var validatedMailboxesList = make([]string, 0, mailboxCountGuesstimate)
		for _, folder := range account.Folders {
			logger.Debug().Str("mailbox", folder).Msg("Processing requested folder")

			// At this point we are looping over the requested folders, but
			// haven't yet confirmed that they exist as mailboxes on the remote
			// server.

			if strings.ToLower(folder) == "inbox" {

				// NOTE: The "inbox" mailbox/folder name is NOT case-sensitive,
				// but *all* others should be considered case-sensitive. We should
				// be able to safely skip validating "inbox" here since it is a
				// required mailbox/folder name, but all the same we will play it
				// safe and perform a case-insensitive check for a match.
				logger.Debug().Str("mailbox", folder).Msg("Performing case-insensitive validation")
				if textutils.InList(folder, mailboxesList, true) {
					validatedMailboxesList = append(validatedMailboxesList, folder)
				}

				continue
			}

			logger.Debug().Str("mailbox", folder).Msg("Performing case-sensitive validation")
			if !textutils.InList(folder, mailboxesList, false) {
				logger.Error().Str("mailbox", folder).Bool("found", false).Msg("")
				nagiosExitState.LastError = fmt.Errorf("mailbox not found: %q", folder)
				nagiosExitState.ServiceOutput = fmt.Sprintf(
					"%s: Mailbox not found",
					nagios.StateCRITICALLabel,
				)
				nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

				return
			}

			// At this point we have confirmed that the requested folder to
			// monitor is in the list of folders found on the server
			logger.Debug().Str("mailbox", folder).Bool("found", true).Msg("")
			validatedMailboxesList = append(validatedMailboxesList, folder)

		}

		// At this point we have created a list of validated mailboxes. Process
		// them to determine number of emails within each of them. Based on our
		// existing check and manual processing schedule, we normally see
		// somewhere between 1 and 5 mail items for normal accounts and under 30
		// for heavily spammed accounts. Preallocating the results slice with a
		// midrange starting value for now, but keeping the initial length at 0
		// to allow append() to work as expected.
		var results = make(mbxs.MailboxCheckResults, 0, 10)
		for _, folder := range validatedMailboxesList {

			logger.Debug().Msg("Selecting mailbox")
			mailbox, err := c.Select(folder, false)
			if err != nil {
				logger.Error().Err(err).Str("mailbox", folder).Msg("Error occurred selecting mailbox")
				nagiosExitState.LastError = err
				nagiosExitState.ServiceOutput = fmt.Sprintf(
					"%s: Error occurred selecting mailbox %s",
					nagios.StateCRITICALLabel,
					folder,
				)
				nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
				return
			}

			logger.Debug().Str("mailbox", folder).Msgf("Mailbox flags: %v", mailbox.Flags)

			logger.Debug().Msgf("%d mail items found in %s for %s",
				mailbox.Messages, folder, account.Username)

			results = append(results, mbxs.MailboxCheckResult{
				MailboxName: folder,
				ItemsFound:  int(mailbox.Messages),
			})
		}

		// Evaluate whether anything was found and sound an alert if so
		if results.GotMail() {
			logger.Debug().Msgf("%d messages found: %s",
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			nagiosExitState.LastError = nil
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"%s: %s: %d messages found: %s",
				nagios.StateWARNINGLabel,
				account.Username,
				results.TotalMessagesFound(),
				results.MessagesFoundSummary(),
			)
			nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
			return
		}
	}

	// Give the all clear: no mail was found
	cfg.Log.Debug().Msg("No messages found to report")

	// these values are known, consistent regardless of checking one or many
	// accounts
	nagiosExitState.LastError = nil
	nagiosExitState.ExitStatusCode = nagios.StateOKExitCode

	// customize ServiceOutput and LongServiceOutput based on number of
	// specified accounts
	setSummary(cfg.Accounts, &nagiosExitState)

	// implied return here :)

}
