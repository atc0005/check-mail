// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package config

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/atc0005/check-mail/internal/logging"
	"github.com/rs/zerolog"
)

// Updated via Makefile builds. Setting placeholder value here so that
// something resembling a version string will be provided for non-Makefile
// builds.
var version string = "x.y.z"

const myAppName string = "check-mail"
const myAppURL string = "https://github.com/atc0005/check-mail"

// Usage is a custom override for the default Help text provided by the flag
// package. Here we prepend some additional metadata to the existing output.
var Usage = func() {
	fmt.Fprintf(flag.CommandLine.Output(), "%s %s\n%s\n\n", myAppName, version, myAppURL)
	fmt.Fprintf(flag.CommandLine.Output(), "Usage of %s:\n", os.Args[0])
	flag.PrintDefaults()
}

// ErrVersionRequested indicates that the user requested application version
// information
var ErrVersionRequested = errors.New("version information requested")

// MailAccount represents an email account listed within a configuration file.
type MailAccount struct {
	Server   string
	Port     int
	Username string
	Password string
	Folders  multiValueFlag

	// Name is often the bare username for the email account, but may not be.
	// This is used as the section header within the configuration file.
	Name string
}

// multiValueFlag is a custom type that satisfies the flag.Value interface in
// order to accept multiple values for some of our flags.
type multiValueFlag []string

// String returns a comma separated string consisting of all slice elements.
func (i *multiValueFlag) String() string {

	// From the `flag` package docs:
	// "The flag package may call the String method with a zero-valued
	// receiver, such as a nil pointer."
	if i == nil {
		return ""
	}

	return strings.Join(*i, ", ")
}

// Set is called once by the flag package, in command line order, for each
// flag present.
func (i *multiValueFlag) Set(value string) error {

	// split comma-separated string into multiple folders, toss whitespace
	folders := strings.Split(value, ",")
	for index, folder := range folders {
		folders[index] = strings.TrimSpace(folder)
	}

	// add them to the collection
	*i = append(*i, folders...)
	return nil
}

// Config represents the application configuration as specified via
// command-line flags.
type Config struct {

	// EmitBranding controls whether "generated by" text is included at the
	// bottom of application output. This output is included in the Nagios
	// dashboard and notifications. This output may not mix well with branding
	// output from other tools such as atc0005/send2teams which also insert
	// their own branding output.
	EmitBranding bool

	// ShowVersion is a flag indicating whether the user opted to display only
	// the version string and then immediately exit the application.
	ShowVersion bool

	// LoggingLevel is the supported logging level for this application.
	LoggingLevel string

	// Accounts is the collection of IMAP mail accounts checked by
	// applications provided by this project.
	Accounts []MailAccount

	// Log is an embedded zerolog Logger initialized via config.New().
	Log zerolog.Logger
}

// Version emits application name, version and repo location.
func Version() string {
	return fmt.Sprintf("%s %s (%s)", myAppName, version, myAppURL)
}

// Branding accepts a message and returns a function that concatenates that
// message with version information. This function is intended to be called as
// a final step before application exit after any other output has already
// been emitted.
func Branding(msg string) func() string {
	return func() string {
		return strings.Join([]string{msg, Version()}, "")
	}
}

// New is a factory function that produces a new Config object based on user
// provided flag and config file values. It is responsible for validating
// user-provided values and initializing the logging settings used by this
// application.
func New(useConfigFile bool) (*Config, error) {
	var config Config

	config.handleFlagsConfig(useConfigFile)

	if config.ShowVersion {
		return nil, ErrVersionRequested
	}

	if err := config.validate(useConfigFile); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	// Note: Nagios doesn't look at stderr, only stdout. We have to make sure
	// that only whatever output is meant for consumption is emitted to stdout
	// and whatever is meant for troubleshooting is sent to stderr. To help
	// keep these two goals separate (and because Nagios doesn't really do
	// anything special with JSON output from plugins), we use stdlib fmt
	// package output functions for Nagios via stdout and logging package for
	// troubleshooting via stderr.
	//
	// We set some common fields here so that we don't have to repeat them
	// explicitly later and then set additional fields while processing each
	// email account. This approach is intended to help standardize the log
	// messages to make them easier to search through later when
	// troubleshooting.
	config.Log = zerolog.New(os.Stderr).With().Caller().
		Str("version", Version()).
		Logger()

	if err := logging.SetLoggingLevel(config.LoggingLevel); err != nil {
		return nil, err
	}

	return &config, nil

}

// validate verifies all Config struct fields have been provided acceptable
// values.
func (c Config) validate(useConfigFile bool) error {

	for _, account := range c.Accounts {
		if account.Folders == nil {
			return fmt.Errorf(
				"one or more folders not provided for account %s",
				account.Name,
			)
		}

		if account.Port < 0 {
			return fmt.Errorf(
				"invalid TCP port number %d provided for account %s",
				account.Port,
				account.Name,
			)
		}

		if account.Username == "" {
			return fmt.Errorf("username not provided for account %s",
				account.Name,
			)
		}

		if account.Password == "" {
			return fmt.Errorf("password not provided for account %s",
				account.Name,
			)
		}

		if account.Server == "" {
			return fmt.Errorf("server FQDN not provided for account %s",
				account.Name,
			)
		}
	}

	requestedLoggingLevel := strings.ToLower(c.LoggingLevel)
	if _, ok := logging.LoggingLevels[requestedLoggingLevel]; !ok {
		return fmt.Errorf("invalid logging level %s", c.LoggingLevel)
	}

	// Optimist
	return nil

}
