// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-mail
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package config

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/rs/zerolog"
)

// Updated via Makefile builds. Setting placeholder value here so that
// something resembling a version string will be provided for non-Makefile
// builds.
var version = "x.y.z"

const myAppName string = "check-mail"
const myAppURL string = "https://github.com/atc0005/check-mail"

// Usage is a custom override for the default Help text provided by the flag
// package. Here we prepend some additional metadata to the existing output.
var Usage = func() {

	// Override default of stderr as destination for help output. This allows
	// Nagios XI and similar monitoring systems to call plugins with the
	// `--help` flag and have it display within the Admin web UI.
	flag.CommandLine.SetOutput(os.Stdout)

	fmt.Fprintln(flag.CommandLine.Output(), "\n"+Version()+"\n")
	fmt.Fprintf(flag.CommandLine.Output(), "Usage of %s:\n", os.Args[0])
	flag.PrintDefaults()
}

// ErrVersionRequested indicates that the user requested application version
// information
var ErrVersionRequested = errors.New("version information requested")

// MailAccount represents an email account listed within a configuration file.
type MailAccount struct {
	Server   string
	Port     int
	Username string
	Password string
	Folders  multiValueFlag

	// Name is often the bare username for the email account, but may not be.
	// This is used as the section header within the configuration file.
	Name string
}

// multiValueFlag is a custom type that satisfies the flag.Value interface in
// order to accept multiple values for some of our flags.
type multiValueFlag []string

// String returns a comma separated string consisting of all slice elements.
func (i *multiValueFlag) String() string {

	// From the `flag` package docs:
	// "The flag package may call the String method with a zero-valued
	// receiver, such as a nil pointer."
	if i == nil {
		return ""
	}

	return strings.Join(*i, ", ")
}

// Set is called once by the flag package, in command line order, for each
// flag present.
func (i *multiValueFlag) Set(value string) error {

	// split comma-separated string into multiple folders, toss whitespace
	folders := strings.Split(value, ",")
	for index, folder := range folders {
		folders[index] = strings.TrimSpace(folder)
	}

	// add them to the collection
	*i = append(*i, folders...)
	return nil
}

// Config represents the application configuration as specified via
// command-line flags.
type Config struct {

	// EmitBranding controls whether "generated by" text is included at the
	// bottom of application output. This output is included in the Nagios
	// dashboard and notifications. This output may not mix well with branding
	// output from other tools such as atc0005/send2teams which also insert
	// their own branding output.
	EmitBranding bool

	// ShowVersion is a flag indicating whether the user opted to display only
	// the version string and then immediately exit the application.
	ShowVersion bool

	// ConfigFileLoaded is an internal flag indicating whether a user-provided
	// config file was specified *and* loaded, or a config file was
	// automatically detected *and* loaded.
	ConfigFileLoaded bool

	// ConfigFile is the path to the user-provided config file. This config
	// file is not currently used by the check_imap_mailbox plugin provided by
	// this project.
	ConfigFile string

	// ConfigFileUsed is an internal field indicating *what* config file was
	// loaded, be it explicitly specified by the user or automatically
	// detected from a known location.
	ConfigFileUsed string

	// NetworkType indicates whether an attempt should be made to connect to
	// only IPv4, only IPv6 or IMAP servers listening on either of IPv4 or
	// IPv6 addresses ("auto").
	NetworkType string

	// minTLSVersion is the keyword representing the minimum version of TLS
	// supported for encrypted IMAP server connections.
	minTLSVersion string

	// ReportFileOutputDir is the full path to the directory where email
	// summary report files will be generated. Not currently used by the
	// Nagios plugin.
	ReportFileOutputDir string

	// LogFileOutputDir is the full path to the directory where log files will
	// be generated. Not currently used by the Nagios plugin.
	LogFileOutputDir string

	// LogFileHandle is reference to a log file for deferred closure.
	LogFileHandle *os.File

	// LoggingLevel is the supported logging level for this application.
	LoggingLevel string

	// Accounts is the collection of IMAP mail accounts checked by
	// applications provided by this project.
	Accounts []MailAccount

	// Log is an embedded zerolog Logger initialized via config.New().
	Log zerolog.Logger
}

// Version emits application name, version and repo location.
func Version() string {
	return fmt.Sprintf("%s %s (%s)", myAppName, version, myAppURL)
}

// Branding accepts a message and returns a function that concatenates that
// message with version information. This function is intended to be called as
// a final step before application exit after any other output has already
// been emitted.
func Branding(msg string) func() string {
	return func() string {
		return strings.Join([]string{msg, Version()}, "")
	}
}

// New is a factory function that produces a new Config object based on user
// provided flag and config file values. It is responsible for validating
// user-provided values and initializing the logging settings used by this
// application.
func New(useConfigFile bool, useLogFile bool) (*Config, error) {
	var config Config

	config.handleFlagsConfig(useConfigFile)

	if config.ShowVersion {
		return nil, ErrVersionRequested
	}

	if err := config.validate(useConfigFile); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	// initialize logging "early", just as soon as validation is complete so
	// that we can rely on it to debug further configuration init work
	if err := config.setupLogging(useLogFile); err != nil {
		return nil, fmt.Errorf(
			"failed to set logging configuration: %w",
			err,
		)
	}

	if useConfigFile {
		if err := config.load(); err != nil {

			// We log this message in an effort to populate the log file with
			// something useful; an empty log file isn't that helpful if
			// someone needs to debug later what happened (and the person
			// running the application didn't catch the error output).
			errMsg := "failed to load configuration file"
			config.Log.Error().Err(err).Msgf(errMsg)

			return nil, fmt.Errorf("%s: %w", errMsg, err)
		}
	}

	// fmt.Printf("config: %+v\n", config)

	return &config, nil

}

// validate verifies all Config struct fields have been provided acceptable
// values.
func (c Config) validate(useConfigFile bool) error {

	// NOTE: It's fine to *not* specify a config file. The expected behavior
	// is that specifying a config file will be a rare thing; users will more
	// often than not rely on config file auto-detection behavior.
	//
	// That said, if a user does not specify a config file, we need to require
	// that one was found and loaded.
	//
	// if useConfigFile {
	// 	if c.ConfigFile == "" {
	// 		return fmt.Errorf("config file required, but not specified")
	// 	}
	// }

	for _, account := range c.Accounts {
		if account.Folders == nil {
			return fmt.Errorf(
				"one or more folders not provided for account %s",
				account.Name,
			)
		}

		if account.Port < 0 {
			return fmt.Errorf(
				"invalid TCP port number %d provided for account %s",
				account.Port,
				account.Name,
			)
		}

		if account.Username == "" {
			return fmt.Errorf("username not provided for account %s",
				account.Name,
			)
		}

		if account.Password == "" {
			return fmt.Errorf("password not provided for account %s",
				account.Name,
			)
		}

		if account.Server == "" {
			return fmt.Errorf("server FQDN not provided for account %s",
				account.Name,
			)
		}
	}

	// these settings only apply to the list-emails application
	if useConfigFile {

		// set with a default value if not specified by the user, so should not
		// ever be empty
		if c.ReportFileOutputDir == "" {
			return fmt.Errorf("missing report file output directory")
		}

		// set with a default value if not specified by the user, so should not
		// ever be empty
		if c.LogFileOutputDir == "" {
			return fmt.Errorf("missing log file output directory")
		}

	}

	switch strings.ToLower(c.minTLSVersion) {
	case minTLSVersion10:
	case minTLSVersion11:
	case minTLSVersion12:
	case minTLSVersion13:
	default:
		return fmt.Errorf("invalid TLS version keyword: %s", c.minTLSVersion)
	}

	switch strings.ToLower(c.NetworkType) {
	case netTypeTCPAuto:
	case netTypeTCP4:
	case netTypeTCP6:
	default:
		return fmt.Errorf("invalid network type keyword: %s", c.NetworkType)
	}

	requestedLoggingLevel := strings.ToLower(c.LoggingLevel)
	if _, ok := loggingLevels[requestedLoggingLevel]; !ok {
		return fmt.Errorf("invalid logging level %s", c.LoggingLevel)
	}

	// Optimist
	return nil

}

// load is a helper function to handle the bulk of the configuration loading
// work for the New constructor function.
func (c *Config) load() error {

	configFiles := make([]string, 0, 3)

	switch {

	// If specified, load user-specified config file.
	case c.ConfigFile != "":

		c.Log.Debug().
			Str("config_file_candidate", c.ConfigFile).
			Msg("Trying to load user-requested config file")

		loadErr := c.loadConfigFile(c.ConfigFile)
		if loadErr != nil {
			return fmt.Errorf(
				"failed to load configuration from file %q: %w",
				c.ConfigFile,
				loadErr,
			)
		}

	// If not explicitly specified, attempt to automatically load a
	// configuration file from known locations preferring to load a local
	// configuration file from the current working directory first.
	case c.ConfigFile == "":

		localINIConfig, localFileErr := c.localConfigFile(defaultINIConfigFileName)
		if localFileErr != nil {
			return fmt.Errorf(
				"failed to construct path to local config file :%w",
				localFileErr,
			)
		}
		configFiles = append(configFiles, localINIConfig)

		userConfigFile, userConfigFileErr := c.userConfigFile(
			myAppName, defaultINIConfigFileName,
		)
		if userConfigFileErr != nil {
			return fmt.Errorf(
				"failed to construct path to user config file :%w",
				userConfigFileErr,
			)
		}
		configFiles = append(configFiles, userConfigFile)

		loadErr := c.loadConfigFile(configFiles...)
		if loadErr != nil {
			return fmt.Errorf(
				"failed to load candidate config files %v: %w",
				configFiles,
				loadErr,
			)
		}
	}

	return nil
}
